{
  "name": "image-puzzle",
  "type": "registry:ui",
  "title": "Image Puzzle",
  "description": "An animated SVG puzzle component with realistic interlocking pieces, sequential animations, and support for custom images via URL. Features optimized performance with React.memo and memoized values.",
  "dependencies": ["framer-motion", "tailwind-merge", "clsx"],
  "registryDependencies": [],
  "files": [
    {
      "path": "components/ui/image-puzzle.tsx",
      "content": "\"use client\";\n\nimport React, { memo, useMemo, useId } from \"react\";\nimport { motion, Transition, Variants } from \"framer-motion\";\nimport { cn } from \"@/lib/utils\";\n\ninterface ImagePuzzleProps {\n  className?: string;\n  imageSrc?: string;\n}\n\n// Default gradient SVG as data URL\nconst DEFAULT_IMAGE = `https://cdn.pulse2.com/cdn/2024/01/Clerk-Logo.jpeg`;\n\ntype TabDirection = \"flat\" | \"out\" | \"in\";\n\ninterface PieceConfig {\n  top: TabDirection;\n  right: TabDirection;\n  bottom: TabDirection;\n  left: TabDirection;\n}\n\ninterface CornerRadii {\n  topLeft?: number;\n  topRight?: number;\n  bottomRight?: number;\n  bottomLeft?: number;\n}\n\ninterface PieceDefinition {\n  key: \"topLeft\" | \"topRight\" | \"bottomLeft\" | \"bottomRight\";\n  config: PieceConfig;\n  corners: CornerRadii;\n  translate: { x: number; y: number };\n  order: number;\n}\n\nconst PUZZLE_SIZE = 400;\nconst PIECE_SIZE = PUZZLE_SIZE / 2;\nconst TAB_WIDTH = PIECE_SIZE * 0.45;\nconst TAB_DEPTH = PIECE_SIZE * 0.22;\nconst CURVE = TAB_WIDTH / 2.6;\nconst CORNER_RADIUS = PIECE_SIZE * 0.12;\n\nconst PIECE_DEFINITIONS: PieceDefinition[] = [\n  {\n    key: \"topLeft\",\n    config: { top: \"flat\", right: \"out\", bottom: \"out\", left: \"flat\" },\n    corners: { topLeft: CORNER_RADIUS },\n    translate: { x: 0, y: 0 },\n    order: 2,\n  },\n  {\n    key: \"topRight\",\n    config: { top: \"flat\", right: \"flat\", bottom: \"out\", left: \"in\" },\n    corners: { topRight: CORNER_RADIUS },\n    translate: { x: PIECE_SIZE, y: 0 },\n    order: 1,\n  },\n  {\n    key: \"bottomLeft\",\n    config: { top: \"in\", right: \"out\", bottom: \"flat\", left: \"flat\" },\n    corners: { bottomLeft: CORNER_RADIUS },\n    translate: { x: 0, y: PIECE_SIZE },\n    order: 3,\n  },\n  {\n    key: \"bottomRight\",\n    config: { top: \"in\", right: \"flat\", bottom: \"flat\", left: \"in\" },\n    corners: { bottomRight: CORNER_RADIUS },\n    translate: { x: PIECE_SIZE, y: PIECE_SIZE },\n    order: 4,\n  },\n];\n\nconst formatCoord = (value: number) => Number(value.toFixed(3));\nconst createPiecePath = (\n  { top, right, bottom, left }: PieceConfig,\n  corners: CornerRadii\n) => {\n  const size = PIECE_SIZE;\n  const half = size / 2;\n\n  const rTopLeft = corners.topLeft ?? 0;\n  const rTopRight = corners.topRight ?? 0;\n  const rBottomRight = corners.bottomRight ?? 0;\n  const rBottomLeft = corners.bottomLeft ?? 0;\n\n  const topFirst = Math.max(rTopLeft, half - TAB_WIDTH / 2);\n  const topSecond = Math.min(size - rTopRight, half + TAB_WIDTH / 2);\n\n  const rightFirst = Math.max(rTopRight, half - TAB_WIDTH / 2);\n  const rightSecond = Math.min(size - rBottomRight, half + TAB_WIDTH / 2);\n\n  const bottomFirst = Math.min(size - rBottomRight, half + TAB_WIDTH / 2);\n  const bottomSecond = Math.max(rBottomLeft, half - TAB_WIDTH / 2);\n\n  const leftFirst = Math.min(size - rBottomLeft, half + TAB_WIDTH / 2);\n  const leftSecond = Math.max(rTopLeft, half - TAB_WIDTH / 2);\n\n  const topSegment = (direction: TabDirection) => {\n    if (direction === \"flat\") {\n      return `L ${formatCoord(size - rTopRight)} 0`;\n    }\n\n    const dir = direction === \"out\" ? -1 : 1;\n    return [\n      `L ${formatCoord(topFirst)} 0`,\n      `C ${formatCoord(topFirst + CURVE)} 0 ${formatCoord(\n        half - CURVE\n      )} ${formatCoord(dir * TAB_DEPTH)} ${formatCoord(half)} ${formatCoord(\n        dir * TAB_DEPTH\n      )}`,\n      `C ${formatCoord(half + CURVE)} ${formatCoord(\n        dir * TAB_DEPTH\n      )} ${formatCoord(topSecond - CURVE)} 0 ${formatCoord(topSecond)} 0`,\n      `L ${formatCoord(size - rTopRight)} 0`,\n    ].join(\" \");\n  };\n\n  const rightSegment = (direction: TabDirection) => {\n    if (direction === \"flat\") {\n      return `L ${formatCoord(size)} ${formatCoord(size - rBottomRight)}`;\n    }\n\n    const dir = direction === \"out\" ? 1 : -1;\n    return [\n      `L ${formatCoord(size)} ${formatCoord(rightFirst)}`,\n      `C ${formatCoord(size)} ${formatCoord(rightFirst + CURVE)} ${formatCoord(\n        size + dir * TAB_DEPTH\n      )} ${formatCoord(half - CURVE)} ${formatCoord(\n        size + dir * TAB_DEPTH\n      )} ${formatCoord(half)}`,\n      `C ${formatCoord(size + dir * TAB_DEPTH)} ${formatCoord(\n        half + CURVE\n      )} ${formatCoord(size)} ${formatCoord(rightSecond - CURVE)} ${formatCoord(\n        size\n      )} ${formatCoord(rightSecond)}`,\n      `L ${formatCoord(size)} ${formatCoord(size - rBottomRight)}`,\n    ].join(\" \");\n  };\n\n  const bottomSegment = (direction: TabDirection) => {\n    if (direction === \"flat\") {\n      return `L ${formatCoord(rBottomLeft)} ${formatCoord(size)}`;\n    }\n\n    const dir = direction === \"out\" ? 1 : -1;\n    return [\n      `L ${formatCoord(bottomFirst)} ${formatCoord(size)}`,\n      `C ${formatCoord(bottomFirst - CURVE)} ${formatCoord(size)} ${formatCoord(\n        half + CURVE\n      )} ${formatCoord(size + dir * TAB_DEPTH)} ${formatCoord(\n        half\n      )} ${formatCoord(size + dir * TAB_DEPTH)}`,\n      `C ${formatCoord(half - CURVE)} ${formatCoord(\n        size + dir * TAB_DEPTH\n      )} ${formatCoord(bottomSecond + CURVE)} ${formatCoord(\n        size\n      )} ${formatCoord(bottomSecond)} ${formatCoord(size)}`,\n      `L ${formatCoord(rBottomLeft)} ${formatCoord(size)}`,\n    ].join(\" \");\n  };\n\n  const leftSegment = (direction: TabDirection) => {\n    if (direction === \"flat\") {\n      return `L 0 ${formatCoord(rTopLeft)}`;\n    }\n\n    const dir = direction === \"out\" ? -1 : 1;\n    return [\n      `L 0 ${formatCoord(leftFirst)}`,\n      `C 0 ${formatCoord(leftFirst - CURVE)} ${formatCoord(\n        dir * TAB_DEPTH\n      )} ${formatCoord(half + CURVE)} ${formatCoord(\n        dir * TAB_DEPTH\n      )} ${formatCoord(half)}`,\n      `C ${formatCoord(dir * TAB_DEPTH)} ${formatCoord(\n        half - CURVE\n      )} 0 ${formatCoord(leftSecond + CURVE)} 0 ${formatCoord(leftSecond)}`,\n      `L 0 ${formatCoord(rTopLeft)}`,\n    ].join(\" \");\n  };\n\n  const commands: string[] = [`M ${formatCoord(rTopLeft)} 0`, topSegment(top)];\n\n  if (rTopRight > 0) {\n    commands.push(\n      `Q ${formatCoord(size)} 0 ${formatCoord(size)} ${formatCoord(rTopRight)}`\n    );\n  }\n\n  commands.push(rightSegment(right));\n\n  if (rBottomRight > 0) {\n    commands.push(\n      `Q ${formatCoord(size)} ${formatCoord(size)} ${formatCoord(\n        size - rBottomRight\n      )} ${formatCoord(size)}`\n    );\n  }\n\n  commands.push(bottomSegment(bottom));\n\n  if (rBottomLeft > 0) {\n    commands.push(\n      `Q 0 ${formatCoord(size)} 0 ${formatCoord(size - rBottomLeft)}`\n    );\n  }\n\n  commands.push(leftSegment(left));\n\n  if (rTopLeft > 0) {\n    commands.push(`Q 0 0 ${formatCoord(rTopLeft)} 0`);\n  }\n\n  commands.push(\"Z\");\n\n  return commands.join(\" \");\n};\n\n// Animation constants - defined outside component to prevent recreation\nconst ANIMATE_IN_DURATION = 2.1;\nconst HOLD_DURATION = 3.0;\nconst ANIMATE_OUT_DURATION = 2.0;\nconst TOTAL_DURATION =\n  ANIMATE_IN_DURATION + HOLD_DURATION + ANIMATE_OUT_DURATION;\nconst PIECE_OFFSET = PIECE_SIZE * 0.32;\n\n// Shared transition config for better performance\nconst createTransition = (times: number[]): Transition => ({\n  duration: TOTAL_DURATION,\n  times,\n  ease: [0.25, 0.1, 0.25, 1], // Custom cubic-bezier for smoother animation\n  repeat: Infinity,\n  repeatType: \"loop\" as const,\n});\n\nexport const ImagePuzzle = memo(\n  ({ className, imageSrc = DEFAULT_IMAGE }: ImagePuzzleProps) => {\n    const rawId = useId();\n    const clipPathPrefix = useMemo(() => rawId.replace(/:/g, \"\"), [rawId]);\n\n    const pieces = useMemo(\n      () =>\n        PIECE_DEFINITIONS.map((piece) => {\n          const path = createPiecePath(piece.config, piece.corners ?? {});\n          const clipId = `${clipPathPrefix}-${piece.key}`;\n          return {\n            ...piece,\n            path,\n            clipId,\n            center: {\n              x: piece.translate.x + PIECE_SIZE / 2,\n              y: piece.translate.y + PIECE_SIZE / 2,\n            },\n          };\n        }).sort((a, b) => a.order - b.order),\n      [clipPathPrefix]\n    );\n\n    // Memoize animation variants to prevent recreation on each render\n    const pieceVariants = useMemo(() => {\n      const topLeft: Variants = {\n        initial: {\n          opacity: 0,\n          x: -PIECE_OFFSET,\n          y: -PIECE_OFFSET,\n          rotate: -15,\n        },\n        animate: {\n          opacity: [0, 1, 1, 1, 0],\n          x: [-PIECE_OFFSET, 0, 0, 0, -PIECE_OFFSET],\n          y: [-PIECE_OFFSET, 0, 0, 0, -PIECE_OFFSET],\n          rotate: [-15, 0, 0, 0, -15],\n        },\n      };\n\n      const topRight: Variants = {\n        initial: { opacity: 0, x: PIECE_OFFSET, y: -PIECE_OFFSET, rotate: 15 },\n        animate: {\n          opacity: [0, 0, 1, 1, 0],\n          x: [PIECE_OFFSET, PIECE_OFFSET, 0, 0, PIECE_OFFSET],\n          y: [-PIECE_OFFSET, -PIECE_OFFSET, 0, 0, -PIECE_OFFSET],\n          rotate: [15, 15, 0, 0, 15],\n        },\n      };\n\n      const bottomLeft: Variants = {\n        initial: { opacity: 0, x: -PIECE_OFFSET, y: PIECE_OFFSET, rotate: -15 },\n        animate: {\n          opacity: [0, 0, 1, 1, 0],\n          x: [-PIECE_OFFSET, -PIECE_OFFSET, 0, 0, -PIECE_OFFSET],\n          y: [PIECE_OFFSET, PIECE_OFFSET, 0, 0, PIECE_OFFSET],\n          rotate: [-15, -15, 0, 0, -15],\n        },\n      };\n\n      const bottomRight: Variants = {\n        initial: { opacity: 0, x: PIECE_OFFSET, y: PIECE_OFFSET, rotate: 15 },\n        animate: {\n          opacity: [0, 0, 1, 1, 0],\n          x: [PIECE_OFFSET, PIECE_OFFSET, 0, 0, PIECE_OFFSET],\n          y: [PIECE_OFFSET, PIECE_OFFSET, 0, 0, PIECE_OFFSET],\n          rotate: [15, 15, 0, 0, 15],\n        },\n      };\n\n      return { topLeft, topRight, bottomLeft, bottomRight };\n    }, []);\n\n    // Memoize transitions to prevent recreation\n    const transitions = useMemo(\n      () => ({\n        topLeft: createTransition([0, 0.1, 0.296, 0.718, 1]),\n        topRight: createTransition([0, 0.15, 0.2, 0.718, 1]),\n        bottomLeft: createTransition([0, 0.2, 0.25, 0.718, 1]),\n        bottomRight: createTransition([0, 0.25, 0.296, 0.718, 1]),\n      }),\n      []\n    );\n\n    return (\n      <div className={cn(\"flex items-center justify-center p-8\", className)}>\n        <div className=\"relative w-full max-w-sm aspect-square overflow-visible\">\n          <motion.svg\n            viewBox={`0 0 ${PUZZLE_SIZE} ${PUZZLE_SIZE}`}\n            className=\"w-full h-full rounded-2xl md:rounded-3xl\"\n            style={{ overflow: \"visible\" }}\n          >\n            <defs>\n              {pieces.map((piece) => (\n                <clipPath\n                  key={piece.clipId}\n                  id={piece.clipId}\n                  clipPathUnits=\"userSpaceOnUse\"\n                >\n                  <path\n                    d={piece.path}\n                    transform={`translate(${piece.translate.x} ${piece.translate.y})`}\n                  />\n                </clipPath>\n              ))}\n            </defs>\n\n            {pieces.map((piece) => (\n              <motion.g\n                key={piece.key}\n                variants={pieceVariants[piece.key]}\n                initial=\"initial\"\n                animate=\"animate\"\n                transition={transitions[piece.key]}\n                style={{\n                  transformOrigin: `${piece.center.x}px ${piece.center.y}px`,\n                  willChange: \"transform, opacity\",\n                }}\n              >\n                <g clipPath={`url(#${piece.clipId})`}>\n                  <image\n                    href={imageSrc}\n                    x=\"0\"\n                    y=\"0\"\n                    width={PUZZLE_SIZE}\n                    height={PUZZLE_SIZE}\n                    preserveAspectRatio=\"xMidYMid slice\"\n                  />\n                </g>\n                <path\n                  d={piece.path}\n                  transform={`translate(${piece.translate.x} ${piece.translate.y})`}\n                  fill=\"none\"\n                  stroke=\"rgba(148,163,184,0.20)\"\n                  strokeWidth={1}\n                  strokeLinejoin=\"round\"\n                  strokeLinecap=\"round\"\n                />\n              </motion.g>\n            ))}\n          </motion.svg>\n        </div>\n      </div>\n    );\n  }\n);\n\nImagePuzzle.displayName = \"ImagePuzzle\";\n\nexport default ImagePuzzle;\n",
      "type": "registry:ui",
      "target": "components/ui/image-puzzle.tsx"
    }
  ]
}
