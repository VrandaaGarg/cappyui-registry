{
  "name": "ai-chat",
  "type": "registry:ui",
  "title": "AI Chat",
  "description": "Animated AI chat component with typing effects, syntax highlighting, and smooth scrolling. Perfect for showcasing conversational AI experiences.",
  "dependencies": [
    "framer-motion",
    "lucide-react",
    "react-shiki",
    "shiki",
    "tailwind-merge",
    "clsx"
  ],
  "registryDependencies": [],
  "files": [
    {
      "path": "components/ui/ai-chat.tsx",
      "content": "\"use client\";\n\nimport React, {\n  memo,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport { motion, useInView } from \"framer-motion\";\nimport { Bot, MessageSquareText, User } from \"lucide-react\";\nimport ShikiHighlighter from \"react-shiki\";\n\nimport { cn } from \"@/lib/utils\";\n\n// Optimized: Memoized theme detection with reduced re-renders\nfunction useThemeDetection() {\n  const [isDarkMode, setIsDarkMode] = useState(() => {\n    if (typeof document === \"undefined\") return false;\n    const root = document.documentElement;\n    return (\n      root.classList.contains(\"dark\") ||\n      root.classList.contains(\"capybara-dark\")\n    );\n  });\n\n  useEffect(() => {\n    const computeIsDark = () => {\n      const root = document.documentElement;\n      return (\n        root.classList.contains(\"dark\") ||\n        root.classList.contains(\"capybara-dark\")\n      );\n    };\n\n    const observer = new MutationObserver(() => {\n      const isDark = computeIsDark();\n      setIsDarkMode((prev) => (prev !== isDark ? isDark : prev)); // Only update if changed\n    });\n\n    observer.observe(document.documentElement, {\n      attributes: true,\n      attributeFilter: [\"class\"], // Only watch class changes\n    });\n\n    return () => observer.disconnect();\n  }, []);\n\n  return isDarkMode;\n}\n\nexport interface ChatDemoMessage {\n  role: \"user\" | \"assistant\";\n  content: string;\n  timestamp: string;\n  thinkingDelay?: number;\n  nextDelay?: number;\n}\n\nconst DEMO_MESSAGES: ChatDemoMessage[] = [\n  {\n    role: \"user\",\n    content: \"What is React?\",\n    timestamp: \"10:24 AM\",\n    thinkingDelay: 1500,\n  },\n  {\n    role: \"assistant\",\n    content:\n      \"React is a JavaScript library for building user interfaces. It lets you create reusable components and efficiently update the UI when your data changes. It's maintained by Meta and widely used for web applications.\",\n    timestamp: \"10:24 AM\",\n    nextDelay: 1200,\n  },\n  {\n    role: \"user\",\n    content: \"Can you show me a simple example?\",\n    timestamp: \"10:26 AM\",\n    thinkingDelay: 1200,\n  },\n  {\n    role: \"assistant\",\n    content:\n      'Sure! Here\\'s a basic React component:\\n\\n```tsx\\nfunction Welcome({ name }) {\\n  return <h1>Hello, {name}!</h1>;\\n}```\\n\\nYou can use it like this: `<Welcome name=\"Sarah\" />` and it will display \"Hello, Sarah!\"',\n    timestamp: \"10:27 AM\",\n    nextDelay: 1200,\n  },\n  {\n    role: \"user\",\n    content: \"That's helpful! What makes React so popular?\",\n    timestamp: \"10:28 AM\",\n    thinkingDelay: 1200,\n  },\n  {\n    role: \"assistant\",\n    content:\n      \"React is popular because it's simple to learn, has a huge community, and makes building interactive UIs easy. The component-based approach helps you break down complex interfaces into smaller, manageable pieces. Plus, it has great performance and works well with other tools!\",\n    timestamp: \"10:29 AM\",\n    nextDelay: 1200,\n  },\n  {\n    role: \"user\",\n    content: \"Thanks! This makes sense now.\",\n    timestamp: \"10:30 AM\",\n    thinkingDelay: 1000,\n  },\n  {\n    role: \"assistant\",\n    content:\n      \"You're welcome! Feel free to ask if you have more questions. Happy coding! ðŸš€\",\n    timestamp: \"10:30 AM\",\n    nextDelay: 1200,\n  },\n];\n\ninterface TypingTextProps {\n  text: string;\n  isVisible: boolean;\n  delay?: number;\n  speed?: number;\n  onComplete?: () => void;\n}\n\nconst TypingText = ({\n  text,\n  isVisible,\n  delay = 0,\n  speed = 20,\n  onComplete,\n}: TypingTextProps) => {\n  const [displayedText, setDisplayedText] = useState(\"\");\n  const [currentIndex, setCurrentIndex] = useState(0);\n  const [hasStarted, setHasStarted] = useState(false);\n\n  useEffect(() => {\n    if (!isVisible) {\n      setDisplayedText(\"\");\n      setCurrentIndex(0);\n      setHasStarted(false);\n      return;\n    }\n\n    if (!hasStarted) {\n      setHasStarted(true);\n      setDisplayedText(\"\");\n      setCurrentIndex(0);\n    }\n  }, [isVisible, hasStarted]);\n\n  useEffect(() => {\n    if (!isVisible || !hasStarted) return;\n\n    const timer = window.setTimeout(\n      () => {\n        if (currentIndex < text.length) {\n          setDisplayedText((prev) => prev + text[currentIndex]);\n          setCurrentIndex((prev) => prev + 1);\n        } else if (onComplete && currentIndex === text.length) {\n          onComplete();\n        }\n      },\n      currentIndex === 0 ? delay : speed\n    );\n\n    return () => window.clearTimeout(timer);\n  }, [isVisible, hasStarted, currentIndex, text, delay, speed, onComplete]);\n\n  return <span className=\"\">{displayedText}</span>;\n};\n\ninterface TypingCodeBlockProps {\n  code: string;\n  isVisible: boolean;\n  delay?: number;\n  speed?: number;\n  onComplete?: () => void;\n  isDarkMode: boolean;\n}\n\nconst TypingCodeBlock = ({\n  code,\n  isVisible,\n  delay = 0,\n  speed = 12,\n  onComplete,\n  isDarkMode,\n}: TypingCodeBlockProps) => {\n  const [displayedCode, setDisplayedCode] = useState(\"\");\n  const [currentIndex, setCurrentIndex] = useState(0);\n  const [hasStarted, setHasStarted] = useState(false);\n\n  useEffect(() => {\n    if (!isVisible) {\n      setDisplayedCode(\"\");\n      setCurrentIndex(0);\n      setHasStarted(false);\n      return;\n    }\n\n    if (!hasStarted) {\n      setHasStarted(true);\n      setDisplayedCode(\"\");\n      setCurrentIndex(0);\n    }\n  }, [isVisible, hasStarted]);\n\n  useEffect(() => {\n    if (!isVisible || !hasStarted) return;\n\n    const timer = window.setTimeout(\n      () => {\n        if (currentIndex < code.length) {\n          setDisplayedCode((prev) => prev + code[currentIndex]);\n          setCurrentIndex((prev) => prev + 1);\n        } else if (onComplete && currentIndex === code.length) {\n          onComplete();\n        }\n      },\n      currentIndex === 0 ? delay : speed\n    );\n\n    return () => window.clearTimeout(timer);\n  }, [isVisible, hasStarted, currentIndex, code, delay, speed, onComplete]);\n\n  return (\n    <div className=\"rounded-lg border border-muted-foreground/20 bg-muted/40 dark:bg-background/40 overflow-x-auto\">\n      <ShikiHighlighter\n        language=\"tsx\"\n        theme={isDarkMode ? \"github-dark\" : \"github-light\"}\n        className=\"text-sm font-mono overflow-x-auto bg-transparent min-w-0 max-w-full\"\n        showLanguage={false}\n      >\n        {displayedCode}\n      </ShikiHighlighter>\n    </div>\n  );\n};\n\n// Optimized: Memoized component for static code blocks\nconst StaticCodeBlock = memo(\n  ({\n    code,\n    language,\n    isDarkMode,\n  }: {\n    code: string;\n    language: string;\n    isDarkMode: boolean;\n  }) => (\n    <div className=\"my-3\">\n      <div className=\"rounded-lg border border-muted-foreground/20 bg-muted/40 dark:bg-background/40 overflow-x-auto\">\n        <ShikiHighlighter\n          language={language}\n          theme={isDarkMode ? \"github-dark\" : \"github-light\"}\n          className=\"text-sm font-mono overflow-x-auto bg-transparent min-w-0 max-w-full\"\n          showLanguage={false}\n        >\n          {code}\n        </ShikiHighlighter>\n      </div>\n    </div>\n  )\n);\nStaticCodeBlock.displayName = \"StaticCodeBlock\";\n\nconst renderStaticSegments = (content: string, isDarkMode: boolean) => {\n  const nodes: React.ReactNode[] = [];\n  let lastIndex = 0;\n  let match: RegExpExecArray | null;\n\n  // Create new regex instance to avoid global state issues\n  const codeBlockRegex = /```(tsx|jsx|javascript|js)?\\n([\\s\\S]*?)```/g;\n\n  while ((match = codeBlockRegex.exec(content)) !== null) {\n    if (match.index > lastIndex) {\n      const textPortion = content.slice(lastIndex, match.index).trim();\n      if (textPortion) {\n        nodes.push(\n          <span key={`text-${nodes.length}`} className=\"mb-2 leading-relaxed \">\n            {renderMarkdown(textPortion)}\n          </span>\n        );\n      }\n    }\n\n    const codeContent = match[2];\n    const language = match[1] || \"tsx\";\n\n    nodes.push(\n      <StaticCodeBlock\n        key={`code-${nodes.length}`}\n        code={codeContent}\n        language={language}\n        isDarkMode={isDarkMode}\n      />\n    );\n\n    lastIndex = match.index + match[0].length;\n  }\n\n  if (lastIndex < content.length) {\n    const remaining = content.slice(lastIndex).trim();\n    if (remaining) {\n      nodes.push(\n        <span key={`text-${nodes.length}`} className=\"leading-relaxed \">\n          {renderMarkdown(remaining)}\n        </span>\n      );\n    }\n  }\n\n  return <>{nodes}</>;\n};\n\n// Helper function to render markdown (bold, inline code)\nconst renderMarkdown = (text: string) => {\n  const parts: React.ReactNode[] = [];\n  let lastIndex = 0;\n\n  // Match **bold** and `inline code`\n  const regex = /(\\*\\*(.+?)\\*\\*)|(`(.+?)`)/g;\n  let match;\n\n  while ((match = regex.exec(text)) !== null) {\n    // Add text before match\n    if (match.index > lastIndex) {\n      parts.push(text.slice(lastIndex, match.index));\n    }\n\n    if (match[2]) {\n      // Bold text\n      parts.push(\n        <strong key={match.index} className=\"font-semibold text-foreground\">\n          {match[2]}\n        </strong>\n      );\n    } else if (match[4]) {\n      // Inline code\n      parts.push(\n        <code\n          key={match.index}\n          className=\"px-1.5 py-0.5 rounded bg-muted text-foreground font-mono text-xs\"\n        >\n          {match[4]}\n        </code>\n      );\n    }\n\n    lastIndex = match.index + match[0].length;\n  }\n\n  // Add remaining text\n  if (lastIndex < text.length) {\n    parts.push(text.slice(lastIndex));\n  }\n\n  return parts.length > 0 ? parts : text;\n};\n\n// Optimized: Memoized content splitting with LRU cache\nclass LRUCache<K, V> {\n  private cache = new Map<K, V>();\n  private maxSize: number;\n\n  constructor(maxSize: number = 50) {\n    this.maxSize = maxSize;\n  }\n\n  get(key: K): V | undefined {\n    const value = this.cache.get(key);\n    if (value !== undefined) {\n      // Move to end (most recently used)\n      this.cache.delete(key);\n      this.cache.set(key, value);\n    }\n    return value;\n  }\n\n  set(key: K, value: V): void {\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    } else if (this.cache.size >= this.maxSize) {\n      // Remove least recently used (first item)\n      const iterator = this.cache.keys();\n      const firstResult = iterator.next();\n      if (!firstResult.done) {\n        this.cache.delete(firstResult.value);\n      }\n    }\n    this.cache.set(key, value);\n  }\n\n  clear(): void {\n    this.cache.clear();\n  }\n}\n\nconst contentCache = new LRUCache<\n  string,\n  Array<{ type: \"text\" | \"code\"; value: string; delay: number }>\n>();\n\nconst splitContent = (content: string) => {\n  // Check cache first\n  const cached = contentCache.get(content);\n  if (cached) {\n    return cached;\n  }\n\n  const segments: Array<\n    | { type: \"text\"; value: string; delay: number }\n    | { type: \"code\"; value: string; delay: number }\n  > = [];\n\n  let lastIndex = 0;\n  let match: RegExpExecArray | null;\n  let cursor = 0;\n\n  // Create new regex instance to avoid global state issues\n  const codeBlockRegex = /```(tsx|jsx|javascript|js)?\\n([\\s\\S]*?)```/g;\n\n  while ((match = codeBlockRegex.exec(content)) !== null) {\n    if (match.index > lastIndex) {\n      const text = content.slice(lastIndex, match.index);\n      segments.push({ type: \"text\", value: text, delay: cursor * 5 });\n      cursor += text.length;\n    }\n\n    const code = match[2];\n    segments.push({ type: \"code\", value: code, delay: cursor * 5 });\n    cursor += code.length;\n\n    lastIndex = match.index + match[0].length;\n  }\n\n  if (lastIndex < content.length) {\n    const remaining = content.slice(lastIndex);\n    segments.push({ type: \"text\", value: remaining, delay: cursor * 5 });\n  }\n\n  // Cache the result\n  contentCache.set(content, segments);\n\n  return segments;\n};\n\nconst AIChat = memo(function AIChat() {\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const scrollRef = useRef<HTMLDivElement | null>(null);\n  const isProgrammatic = useRef(false);\n  const timeoutsRef = useRef<number[]>([]);\n  const shouldAutoScroll = useRef(true);\n\n  const isInView = useInView(containerRef, { amount: 0.3, once: true });\n  const isDarkMode = useThemeDetection();\n\n  const [currentIndex, setCurrentIndex] = useState(-1);\n  const [completedMessages, setCompletedMessages] = useState<Set<number>>(\n    () => new Set()\n  );\n  const [isTyping, setIsTyping] = useState(false);\n  const [showThinking, setShowThinking] = useState(false);\n  const [isFinished, setIsFinished] = useState(false);\n  const [currentSegmentIndex, setCurrentSegmentIndex] = useState(0);\n  const [completedSegments, setCompletedSegments] = useState<Set<number>>(\n    () => new Set()\n  );\n\n  const scheduleTimeout = useCallback((handler: () => void, delay: number) => {\n    const id = window.setTimeout(() => {\n      handler();\n      timeoutsRef.current = timeoutsRef.current.filter(\n        (storedId) => storedId !== id\n      );\n    }, delay);\n\n    timeoutsRef.current.push(id);\n    return id;\n  }, []);\n\n  const clearScheduled = useCallback(() => {\n    timeoutsRef.current.forEach((id) => window.clearTimeout(id));\n    timeoutsRef.current = [];\n  }, []);\n\n  const checkIfAtBottom = useCallback(() => {\n    const node = scrollRef.current;\n    if (!node) return true;\n\n    const threshold = 50; // pixels from bottom\n    const isAtBottom =\n      node.scrollHeight - node.scrollTop - node.clientHeight <= threshold;\n    return isAtBottom;\n  }, []);\n\n  const scrollToBottom = useCallback(() => {\n    const node = scrollRef.current;\n    if (!node) return;\n\n    isProgrammatic.current = true;\n    node.scrollTop = node.scrollHeight;\n\n    // Use setTimeout to ensure flag is cleared after scroll event\n    setTimeout(() => {\n      isProgrammatic.current = false;\n    }, 100);\n  }, []);\n\n  useEffect(\n    () => () => {\n      clearScheduled();\n      // Clear cache when component unmounts to prevent memory leaks\n      contentCache.clear();\n    },\n    [clearScheduled]\n  );\n\n  useEffect(() => {\n    if (isInView && currentIndex === -1 && !isFinished) {\n      scheduleTimeout(() => {\n        setCurrentIndex(0);\n        setIsTyping(true);\n        shouldAutoScroll.current = true; // Ensure auto-scroll is on when starting\n      }, 400);\n    }\n  }, [currentIndex, isFinished, isInView, scheduleTimeout]);\n\n  useEffect(() => {\n    // Auto-scroll only if shouldAutoScroll is true\n    if (shouldAutoScroll.current) {\n      scrollToBottom();\n    }\n  }, [currentIndex, isTyping, showThinking, scrollToBottom]);\n\n  // Auto-scroll during typing with throttled MutationObserver\n  useEffect(() => {\n    const node = scrollRef.current;\n    if (!node || !isTyping) return;\n\n    let timeoutId: NodeJS.Timeout | null = null;\n    let lastScrollTime = 0;\n\n    const observer = new MutationObserver(() => {\n      // Don't scroll if user has disabled auto-scroll\n      if (!shouldAutoScroll.current) return;\n\n      // Throttle to prevent rapid scrolling\n      const now = Date.now();\n      if (now - lastScrollTime < 100) return; // Increased throttle to 100ms\n\n      if (timeoutId) return;\n\n      timeoutId = setTimeout(() => {\n        if (shouldAutoScroll.current) {\n          lastScrollTime = Date.now();\n          scrollToBottom();\n        }\n        timeoutId = null;\n      }, 100);\n    });\n\n    observer.observe(node, {\n      childList: true,\n      subtree: true,\n      characterData: true,\n    });\n\n    return () => {\n      observer.disconnect();\n      if (timeoutId) clearTimeout(timeoutId);\n    };\n  }, [isTyping, scrollToBottom]);\n\n  // Smart scroll detection: allow user to scroll, but resume auto-scroll when at bottom\n  useEffect(() => {\n    const node = scrollRef.current;\n    if (!node) return;\n\n    const handleScroll = () => {\n      // Ignore programmatic scrolls\n      if (isProgrammatic.current) return;\n\n      // User is manually scrolling - disable auto-scroll immediately\n      shouldAutoScroll.current = false;\n\n      // Check if user scrolled back to bottom\n      const atBottom = checkIfAtBottom();\n\n      // Re-enable auto-scroll only if at bottom\n      if (atBottom) {\n        shouldAutoScroll.current = true;\n      }\n    };\n\n    node.addEventListener(\"scroll\", handleScroll, { passive: true });\n\n    return () => {\n      node.removeEventListener(\"scroll\", handleScroll);\n    };\n  }, [checkIfAtBottom]);\n\n  const handleSegmentComplete = useCallback(\n    (segmentIndex: number, totalSegments: number) => {\n      setCompletedSegments((prev) => {\n        const next = new Set(prev);\n        next.add(segmentIndex);\n        return next;\n      });\n\n      // If this is the last segment, complete the message\n      if (segmentIndex === totalSegments - 1) {\n        // Reset segment tracking for next message\n        setCurrentSegmentIndex(0);\n        setCompletedSegments(new Set());\n\n        if (currentIndex < 0) return;\n\n        setCompletedMessages((prev) => {\n          const next = new Set(prev);\n          next.add(currentIndex);\n          return next;\n        });\n        setIsTyping(false);\n\n        const nextIndex = currentIndex + 1;\n        const currentMessage = DEMO_MESSAGES[currentIndex];\n        const nextMessage = DEMO_MESSAGES[nextIndex];\n\n        if (!nextMessage) {\n          setIsFinished(true);\n          setShowThinking(false);\n          setCurrentIndex(-1);\n          return;\n        }\n\n        if (\n          currentMessage.role === \"user\" &&\n          nextMessage.role === \"assistant\"\n        ) {\n          setShowThinking(true);\n          scheduleTimeout(() => {\n            setShowThinking(false);\n            setCurrentIndex(nextIndex);\n            setIsTyping(true);\n            shouldAutoScroll.current = true; // Re-enable auto-scroll for new message\n          }, currentMessage.thinkingDelay ?? 1400);\n          return;\n        }\n\n        scheduleTimeout(() => {\n          setCurrentIndex(nextIndex);\n          setIsTyping(true);\n          shouldAutoScroll.current = true; // Re-enable auto-scroll for new message\n        }, currentMessage.nextDelay ?? 1400);\n      } else {\n        // Move to next segment\n        setCurrentSegmentIndex(segmentIndex + 1);\n      }\n    },\n    [currentIndex, scheduleTimeout]\n  );\n\n  const handleReplay = useCallback(() => {\n    clearScheduled();\n    setCurrentIndex(-1);\n    setCompletedMessages(new Set());\n    setIsTyping(false);\n    setShowThinking(false);\n    setIsFinished(false);\n    setCurrentSegmentIndex(0);\n    setCompletedSegments(new Set());\n  }, [clearScheduled]);\n\n  const visibleMessages = useMemo(() => {\n    if (currentIndex === -1) {\n      return Array.from(completedMessages.values()).sort((a, b) => a - b);\n    }\n    const baseline = new Set(completedMessages);\n    baseline.add(currentIndex);\n    return Array.from(baseline.values()).sort((a, b) => a - b);\n  }, [completedMessages, currentIndex]);\n\n  return (\n    <div\n      ref={containerRef}\n      className=\"flex h-[480px] w-full flex-col rounded-3xl border border-ring/40 bg-card/40 backdrop-blur\"\n    >\n      <div className=\"mb-4 p-6 flex items-center gap-3 border-b border-ring/30 \">\n        <div className=\"flex gap-3 items-center justify-center rounded-full bg-primary/15 text-primary\">\n          <MessageSquareText className=\"h-5 w-5\" />\n          <span className=\"text-sm font-semibold\">AI Chat</span>\n        </div>\n\n        <div className=\"ml-auto flex items-center gap-2 text-xs text-muted-foreground\">\n          <span className=\"h-2 w-2 animate-pulse rounded-full bg-emerald-500\" />\n          Live Demo\n        </div>\n      </div>\n\n      <div\n        ref={scrollRef}\n        className=\"flex-1 p-4 space-y-4 overflow-y-auto overflow-x-auto scrollbar-visible\"\n      >\n        {visibleMessages.map((index) => {\n          const message = DEMO_MESSAGES[index];\n          const isCurrent = index === currentIndex;\n          const isComplete = completedMessages.has(index);\n          const show = isCurrent || isComplete;\n\n          if (!show) return null;\n\n          const segments = splitContent(message.content);\n\n          return (\n            <motion.div\n              key={index}\n              initial={{ opacity: 0, y: 12 }}\n              animate={{ opacity: 1, y: 0 }}\n              transition={{ type: \"spring\", stiffness: 320, damping: 26 }}\n              className={cn(\n                \"flex gap-3\",\n                message.role === \"user\" ? \"justify-end\" : \"justify-start\"\n              )}\n            >\n              {message.role === \"assistant\" && (\n                <div className=\"mt-1 flex h-9 w-9 flex-shrink-0 items-center justify-center rounded-full border border-primary/30 bg-primary/15 text-primary\">\n                  <Bot className=\"h-4 w-4\" />\n                </div>\n              )}\n              <div\n                className={cn(\n                  \"relative max-w-[80%] rounded-2xl px-4 py-3 text-sm shadow-sm\",\n                  message.role === \"user\"\n                    ? \"rounded-br-sm bg-secondary text-secondary-foreground\"\n                    : \"rounded-bl-sm border border-border/20 bg-muted/60 text-muted-foreground\"\n                )}\n              >\n                <div className=\"leading-relaxed\">\n                  {isComplete\n                    ? renderStaticSegments(message.content, isDarkMode)\n                    : segments.map((segment, segmentIndex) => {\n                        const isCurrentSegment =\n                          segmentIndex === currentSegmentIndex;\n                        const isCompletedSegment =\n                          completedSegments.has(segmentIndex);\n                        const shouldShow =\n                          isCurrent && (isCurrentSegment || isCompletedSegment);\n                        const shouldAnimate =\n                          isCurrent && isCurrentSegment && isTyping;\n\n                        if (segment.type === \"text\") {\n                          return (\n                            <span key={`text-${segmentIndex}`}>\n                              {isCompletedSegment ? (\n                                <span className=\"\">{segment.value}</span>\n                              ) : shouldShow ? (\n                                <TypingText\n                                  text={segment.value}\n                                  isVisible={shouldAnimate}\n                                  delay={0}\n                                  speed={25}\n                                  onComplete={() =>\n                                    handleSegmentComplete(\n                                      segmentIndex,\n                                      segments.length\n                                    )\n                                  }\n                                />\n                              ) : null}\n                            </span>\n                          );\n                        }\n\n                        return (\n                          <div key={`code-${segmentIndex}`} className=\"my-3\">\n                            {isCompletedSegment ? (\n                              <div className=\"rounded-lg border border-muted-foreground/20 bg-muted/40 dark:bg-background/40 overflow-x-auto\">\n                                <ShikiHighlighter\n                                  language=\"tsx\"\n                                  theme={\n                                    isDarkMode ? \"github-dark\" : \"github-light\"\n                                  }\n                                  className=\"text-sm font-mono overflow-x-auto bg-transparent min-w-0 max-w-full\"\n                                  showLanguage={false}\n                                >\n                                  {segment.value}\n                                </ShikiHighlighter>\n                              </div>\n                            ) : shouldShow ? (\n                              <TypingCodeBlock\n                                code={segment.value}\n                                isVisible={shouldAnimate}\n                                delay={0}\n                                speed={12}\n                                onComplete={() =>\n                                  handleSegmentComplete(\n                                    segmentIndex,\n                                    segments.length\n                                  )\n                                }\n                                isDarkMode={isDarkMode}\n                              />\n                            ) : null}\n                          </div>\n                        );\n                      })}\n                </div>\n                <div className=\"mt-3 flex items-center gap-2 text-xs text-muted-foreground/70\">\n                  <span>{message.timestamp}</span>\n                </div>\n              </div>\n              {message.role === \"user\" && (\n                <div className=\"mt-1 flex h-9 w-9 flex-shrink-0 items-center justify-center rounded-full border border-primary/25 bg-primary/10 text-primary\">\n                  <User className=\"h-4 w-4\" />\n                </div>\n              )}\n            </motion.div>\n          );\n        })}\n\n        {showThinking && (\n          <motion.div\n            initial={{ opacity: 0, y: 10 }}\n            animate={{ opacity: 1, y: 0 }}\n            exit={{ opacity: 0, y: -10 }}\n            transition={{ duration: 0.25, ease: \"easeOut\" }}\n            className=\"flex justify-start gap-3\"\n          >\n            <div className=\"mt-1 flex h-9 w-9 flex-shrink-0 items-center justify-center rounded-full border border-primary/30 bg-primary/15 text-primary\">\n              <Bot className=\"h-4 w-4\" />\n            </div>\n            <div className=\"rounded-2xl rounded-bl-md border border-border/20 bg-muted/60 px-4 py-3 text-sm text-muted-foreground\">\n              <div className=\"flex items-center gap-2\">\n                <span>Assistant is thinking</span>\n                <motion.span\n                  className=\"flex items-center gap-1\"\n                  animate={{ opacity: [0.5, 1, 0.5] }}\n                  transition={{ repeat: Infinity, duration: 1.8 }}\n                >\n                  Â·Â·Â·\n                </motion.span>\n              </div>\n            </div>\n          </motion.div>\n        )}\n\n        {isFinished && (\n          <motion.div\n            initial={{ opacity: 0, y: 10 }}\n            animate={{ opacity: 1, y: 0 }}\n            transition={{ duration: 0.2, ease: \"easeOut\" }}\n            className=\"mt-6 flex justify-center\"\n          >\n            <button\n              type=\"button\"\n              onClick={handleReplay}\n              className=\"flex items-center gap-2 rounded-lg border border-primary/40 bg-primary/10 px-4 py-2 text-sm font-medium text-primary transition-colors hover:bg-primary/15\"\n            >\n              <MessageSquareText className=\"h-4 w-4\" />\n              Replay Demo\n            </button>\n          </motion.div>\n        )}\n      </div>\n    </div>\n  );\n});\n\nAIChat.displayName = \"AIChat\";\n\nexport default AIChat;\n",
      "type": "registry:ui",
      "target": "components/ui/ai-chat.tsx"
    }
  ]
}
